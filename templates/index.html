<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>64x64 Matrix Simulator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .matrix-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
        }
        .header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .card {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .navbar {
            background-color: #333;
            overflow: hidden;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .navbar a {
            float: left;
            display: block;
            color: white;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
        }
        .navbar a:hover {
            background-color: #ddd;
            color: black;
        }
        .navbar a.active {
            background-color: #4CAF50;
            color: white;
        }
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .control-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        .button-blue {
            background-color: #2196F3;
        }
        .button-red {
            background-color: #dc3545;
        }
        .matrix-container {
            display: grid;
            grid-template-columns: repeat(64, 10px); 
            grid-template-rows: repeat(64, 10px);    
            border: 1px solid #999;
            background-color: #000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: relative;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .pixel {
            width: 10px;
            height: 10px;
            background-color: #000000;
            border: 1px solid #222; 
            box-sizing: border-box;
        }
        /* Preserve widget overlay styles */
        #widget-overlay-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .draggable-widget-representation {
            position: absolute;
            background-color: transparent;
            border: 1px dashed #61dafb;
            cursor: grab;
            pointer-events: auto;
            box-sizing: border-box;
        }
        .draggable-widget-representation:active {
            cursor: grabbing;
            z-index: 10;
        }
        #widget-overlay-container.bounding-boxes-hidden .draggable-widget-representation {
            display: none;
        }
        .center-guide {
            position: absolute;
            background-color: rgba(255, 0, 0, 0.7);
            display: none;
            z-index: 5;
            pointer-events: none;
        }
        #horizontal-center-guide {
            width: 100%;
            height: 1px;
            left: 0;
        }
        #vertical-center-guide {
            height: 100%;
            width: 1px;
            top: 0;
        }
        select {
            padding: 8px;
            border-radius: 4px;
            background-color: white;
            border: 1px solid #ccc;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .checkbox-label input[type="checkbox"] {
            margin-right: 8px;
        }
        /* Debug panel */
        .debug-panel {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-top: 20px;
        }
        .debug-panel h3 {
            margin-top: 0;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="navbar">
            <a href="/" class="active">Home</a>
            <a href="/config">Configuration</a>
            <a href="/performance">Performance</a>
        </div>
        
        <div class="header">
            <h1>Matrix Display Control</h1>
        </div>
        
        <div class="card">
            <div class="controls-container">
                <div class="control-item">
                    <button id="toggleEditModeBtn" class="button button-red">LIVE Mode</button>
                </div>
                <div class="control-item">
                    <label for="liveScreenSelector" style="margin-right: 10px;">Active Screen:</label>
                    <select id="liveScreenSelector"></select>
                </div>
                <div class="control-item">
                    <label class="checkbox-label" for="enableScreenRotationCheckbox">
                        <input type="checkbox" id="enableScreenRotationCheckbox">
                        Enable Auto Screen Rotation
                    </label>
                </div>
            </div>
        </div>

        <div class="matrix-wrapper">
            <div class="matrix-container" id="matrixGrid">
                <!-- Pixels will be generated by JavaScript -->
                <div id="widget-overlay-container">
                    <!-- Draggable widget representations will be added here -->
                </div>
                <div id="horizontal-center-guide" class="center-guide"></div>
                <div id="vertical-center-guide" class="center-guide"></div>
            </div>
        </div>

        <div class="card">
            <div class="controls-container">
                <button id="btnHome" class="button">Previous</button>
                <button id="btnNetConfig" class="button">Next</button>
                <button id="btnConfigure" class="button">Configure Widgets</button>
            </div>
        </div>

        <!-- Debug Panel -->
        <div class="card debug-panel">
            <h3>Debug Controls</h3>
            <div class="control-item">
                <button id="toggleMatrixLogsBtn" class="button">Toggle Matrix Req. Logs</button>
            </div>
            <!-- Add other debug buttons here in the future -->
        </div>
    </div>

    <script>
        const MATRIX_WIDTH = 64;
        const MATRIX_HEIGHT = 64;
        const matrixGrid = document.getElementById('matrixGrid');
        const menuButtons = {
            previous: document.getElementById('btnHome'),
            next: document.getElementById('btnNetConfig'),
            configure: document.getElementById('btnConfigure')
        };
        let currentMode = 'default'; // To track the active menu item
        const CELL_SIZE = 10; // Each cell is 10px by 10px

        let currentScreenLayouts = {};
        let jsCurrentDisplayMode = 'default'; // Mirror backend's initial display mode
        let draggedWidgetElement = null;
        let offsetX, offsetY;
        let isEditMode = false; // Default to LIVE mode

        const widgetOverlayContainer = document.getElementById('widget-overlay-container');
        const toggleEditModeBtn = document.getElementById('toggleEditModeBtn'); // New button
        const liveScreenSelector = document.getElementById('liveScreenSelector'); 
        const enableScreenRotationCheckbox = document.getElementById('enableScreenRotationCheckbox');
        const toggleMatrixLogsBtn = document.getElementById('toggleMatrixLogsBtn');
        const horizontalCenterGuide = document.getElementById('horizontal-center-guide');
        const verticalCenterGuide = document.getElementById('vertical-center-guide');

        let rotationTimeoutId = null;
        let currentRotationScreenIndex = 0; // To keep track of which screen is next in rotation
        let currentWidgetDimensions = []; // To store dimensions from API

        // Create the grid cells
        for (let r = 0; r < MATRIX_HEIGHT; r++) {
            for (let c = 0; c < MATRIX_WIDTH; c++) {
                const pixel = document.createElement('div');
                pixel.classList.add('pixel');
                pixel.id = `pixel-${r}-${c}`;
                matrixGrid.appendChild(pixel);
            }
        }

        async function fetchAndUpdateMatrix() {
            try {
                const response = await fetch('/api/matrix_data');
                if (!response.ok) {
                    console.error("Failed to fetch matrix data:", response.status);
                    // Also render draggable widgets even if matrix data fails, as layouts might be available
                    renderDraggableWidgets(); 
                    return;
                }
                const data = await response.json();
                
                if (data.pixels) {
                    jsCurrentDisplayMode = data.current_display_mode || jsCurrentDisplayMode;
                    currentWidgetDimensions = data.widgets_dimensions || []; // Store widget dimensions
                     for (let r = 0; r < MATRIX_HEIGHT; r++) {
                        for (let c = 0; c < MATRIX_WIDTH; c++) {
                            const pixelElement = document.getElementById(`pixel-${r}-${c}`);
                            if (pixelElement) {
                                const color = data.pixels[r][c]; // color is an [R, G, B] array
                                if (Array.isArray(color) && color.length === 3) {
                                    pixelElement.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                                } else {
                                    // Fallback or error handling if color data is not as expected
                                    pixelElement.style.backgroundColor = '#000000'; // Default to black
                                }
                            }
                        }
                    }
                } else { // Fallback for old data structure (just the array) - This path might be removable if API always returns new structure
                     for (let r = 0; r < MATRIX_HEIGHT; r++) {
                        for (let c = 0; c < MATRIX_WIDTH; c++) {
                            const pixelElement = document.getElementById(`pixel-${r}-${c}`);
                            if (pixelElement) {
                                // Assuming old structure used 1 for on, 0 for off, and on was green
                                if (data[r][c] === 1) { 
                                    pixelElement.style.backgroundColor = 'rgb(0, 255, 0)'; // Green for old 'on' state
                                } else {
                                    pixelElement.style.backgroundColor = 'rgb(0, 0, 0)';   // Black for old 'off' state
                                }
                            }
                        }
                    }
                }
                // After updating pixels, ensure draggable widgets are also up-to-date
                renderDraggableWidgets();

            } catch (error) {
                console.error("Error fetching or updating matrix:", error);
                 renderDraggableWidgets(); // Still try to render widgets
            }
        }

        async function fetchScreenLayouts() {
            try {
                const response = await fetch('/api/get_screen_layouts');
                if (!response.ok) {
                    console.error('Failed to fetch screen layouts:', response.status);
                    currentScreenLayouts = {}; 
                    return;
                }
                const oldLayoutsString = JSON.stringify(currentScreenLayouts);
                currentScreenLayouts = await response.json();
                console.log("Fetched screen layouts:", currentScreenLayouts);
                // If layouts changed, or liveScreenSelector is empty, repopulate it.
                if (oldLayoutsString !== JSON.stringify(currentScreenLayouts) || liveScreenSelector.options.length === 0) {
                    populateLiveScreenSelector();
                }
            } catch (error) {
                console.error('Error fetching screen layouts:', error);
                currentScreenLayouts = {};
                populateLiveScreenSelector(); // Attempt to populate, might show "no screens"
            }
        }

        function renderDraggableWidgets() {
            // Ensure the container's visibility class is correctly set based on the checkbox OR isEditMode
            if (!isEditMode) { // If not in edit mode, always hide
                widgetOverlayContainer.classList.add('bounding-boxes-hidden');
            } else { // In edit mode, always show (CSS might still hide individual elements if needed, but container is ready)
                widgetOverlayContainer.classList.remove('bounding-boxes-hidden');
            }

            const activeDraggedWidgetId = draggedWidgetElement ? draggedWidgetElement.dataset.widgetId : null;
            
            // Create a set of widget IDs that are currently in the DOM from the previous render
            const existingWidgetRepIds = new Set();
            Array.from(widgetOverlayContainer.children).forEach(child => {
                if (child.id.startsWith('drag-widget-')) {
                    existingWidgetRepIds.add(child.id);
                }
            });

            const currentScreenConfig = currentScreenLayouts && jsCurrentDisplayMode ? currentScreenLayouts[jsCurrentDisplayMode] : null;
            const widgetsToRenderConfig = (currentScreenConfig && currentScreenConfig.widgets) ? currentScreenConfig.widgets : [];
            const renderedWidgetRepIds = new Set(); // Keep track of widget reps processed in this pass

            widgetsToRenderConfig.forEach(widgetConfig => {
                if (!widgetConfig.enabled) return;

                const widgetRepId = `drag-widget-${widgetConfig.id}`;
                renderedWidgetRepIds.add(widgetRepId);
                let widgetRep = document.getElementById(widgetRepId);

                // If this widget is the one currently being dragged
                if (activeDraggedWidgetId === widgetConfig.id && draggedWidgetElement === widgetRep) {
                    // Ensure its dimensions are up-to-date. Position is handled by onMouseMove.
                    const dims = currentWidgetDimensions.find(d => d.id === widgetConfig.id);
                    let widgetGridWidth = dims ? (dims.width_cells > 0 ? dims.width_cells : 1) : 5;
                    let widgetGridHeight = dims ? (dims.height_cells > 0 ? dims.height_cells : 1) : 7;
                    
                    draggedWidgetElement.style.width = (widgetGridWidth * CELL_SIZE) + 'px';
                    draggedWidgetElement.style.height = (widgetGridHeight * CELL_SIZE) + 'px';
                    draggedWidgetElement.dataset.gridWidth = widgetGridWidth;
                    draggedWidgetElement.dataset.gridHeight = widgetGridHeight;
                    // DO NOT set left/top here for the dragged element; onMouseMove handles it.
                    return; // Skip further processing for this widget
                }

                // If widgetRep doesn't exist, create it
                if (!widgetRep) {
                    widgetRep = document.createElement('div');
                    widgetRep.classList.add('draggable-widget-representation');
                    widgetRep.id = widgetRepId;
                    widgetRep.dataset.widgetId = widgetConfig.id;
                    widgetRep.addEventListener('mousedown', onMouseDown);
                    widgetOverlayContainer.appendChild(widgetRep);
                }

                // Update position (from config) and dimensions for non-dragged or newly created widgets
                widgetRep.style.left = (widgetConfig.x * CELL_SIZE) + 'px';
                widgetRep.style.top = (widgetConfig.y * CELL_SIZE) + 'px';

                const dims = currentWidgetDimensions.find(d => d.id === widgetConfig.id);
                let widgetGridWidth = dims ? (dims.width_cells > 0 ? dims.width_cells : 1) : 5;
                let widgetGridHeight = dims ? (dims.height_cells > 0 ? dims.height_cells : 1) : 7;

                widgetRep.style.width = (widgetGridWidth * CELL_SIZE) + 'px';
                widgetRep.style.height = (widgetGridHeight * CELL_SIZE) + 'px';
                widgetRep.dataset.gridWidth = widgetGridWidth;
                widgetRep.dataset.gridHeight = widgetGridHeight;
            });

            // Cleanup: Remove any widget representations from the DOM that are no longer in the config
            // or correspond to a disabled widget, but ensure not to remove the actively dragged one.
            existingWidgetRepIds.forEach(existingId => {
                if (!renderedWidgetRepIds.has(existingId)) {
                    // If the widget is not in the current render list (e.g. screen changed, widget removed/disabled)
                    // AND it's not the actively dragged element, remove it.
                    if (!(activeDraggedWidgetId && `drag-widget-${activeDraggedWidgetId}` === existingId)) {
                         const elToRemove = document.getElementById(existingId);
                         if (elToRemove) {
                            widgetOverlayContainer.removeChild(elToRemove);
                         }
                    }
                }
            });
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; // Only main mouse button
            if (!isEditMode) return; // Only allow dragging in Edit Mode

            draggedWidgetElement = event.target.closest('.draggable-widget-representation');
            if (!draggedWidgetElement) return;

            event.preventDefault(); // Prevent text selection, etc.
            draggedWidgetElement.style.cursor = 'grabbing';

            // Hide centering guides on new drag start
            if (horizontalCenterGuide) horizontalCenterGuide.style.display = 'none';
            if (verticalCenterGuide) verticalCenterGuide.style.display = 'none';

            // Calculate offset from mouse pointer to top-left of element
            const rect = draggedWidgetElement.getBoundingClientRect();
            // const overlayRect = widgetOverlayContainer.getBoundingClientRect(); // Not needed here if offsetX/Y are relative to element
            offsetX = event.clientX - rect.left;
            offsetY = event.clientY - rect.top;
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp, { once: true }); // { once: true } automatically removes listener
        }

        function onMouseMove(event) {
            if (!draggedWidgetElement) return;

            const overlayRect = widgetOverlayContainer.getBoundingClientRect();
            // Calculate the desired top-left position of the element based on mouse movement
            let targetPixelX = event.clientX - offsetX - overlayRect.left;
            let targetPixelY = event.clientY - offsetY - overlayRect.top;

            // Convert to grid coordinates and snap
            let snappedGridX = Math.round(targetPixelX / CELL_SIZE);
            let snappedGridY = Math.round(targetPixelY / CELL_SIZE);

            // Get widget dimensions in grid cells from its dataset
            const widgetGridWidth = parseInt(draggedWidgetElement.dataset.gridWidth) || 1;
            const widgetGridHeight = parseInt(draggedWidgetElement.dataset.gridHeight) || 1;

            // Clamp grid coordinates to ensure the entire widget stays within the matrix
            snappedGridX = Math.max(0, Math.min(snappedGridX, MATRIX_WIDTH - widgetGridWidth));
            snappedGridY = Math.max(0, Math.min(snappedGridY, MATRIX_HEIGHT - widgetGridHeight));

            // Convert snapped grid coordinates back to pixel values for display
            const finalPixelX = snappedGridX * CELL_SIZE;
            const finalPixelY = snappedGridY * CELL_SIZE;

            draggedWidgetElement.style.left = finalPixelX + 'px';
            draggedWidgetElement.style.top = finalPixelY + 'px';

            // Centering guides logic
            const widgetCenterX = snappedGridX + widgetGridWidth / 2;
            const widgetCenterY = snappedGridY + widgetGridHeight / 2;
            const matrixCenterX = MATRIX_WIDTH / 2;
            const matrixCenterY = MATRIX_HEIGHT / 2;
            const tolerance = 0.5; // Cells. A widget center must be within this distance of matrix center.

            // Vertical guide for horizontal centering
            if (Math.abs(widgetCenterX - matrixCenterX) <= tolerance) {
                if (verticalCenterGuide) {
                    verticalCenterGuide.style.display = 'block';
                    // Center the 1px guide line itself on the matrix center line
                    verticalCenterGuide.style.left = (matrixCenterX * CELL_SIZE - (parseInt(getComputedStyle(verticalCenterGuide).width, 10) / 2)) + 'px';
                }
            } else {
                if (verticalCenterGuide) verticalCenterGuide.style.display = 'none';
            }

            // Horizontal guide for vertical centering
            if (Math.abs(widgetCenterY - matrixCenterY) <= tolerance) {
                if (horizontalCenterGuide) {
                    horizontalCenterGuide.style.display = 'block';
                    // Center the 1px guide line itself on the matrix center line
                    horizontalCenterGuide.style.top = (matrixCenterY * CELL_SIZE - (parseInt(getComputedStyle(horizontalCenterGuide).height, 10) / 2)) + 'px';
                }
            } else {
                if (horizontalCenterGuide) horizontalCenterGuide.style.display = 'none';
            }
        }

        async function onMouseUp(event) {
            if (!draggedWidgetElement) return;
            
            // First reset cursor and hide guides immediately
            draggedWidgetElement.style.cursor = 'grab';
            if (horizontalCenterGuide) horizontalCenterGuide.style.display = 'none';
            if (verticalCenterGuide) verticalCenterGuide.style.display = 'none';

            const widgetId = draggedWidgetElement.dataset.widgetId;
            
            // Calculate grid cell based on the top-left of the dragged element
            let gridX = Math.round(parseFloat(draggedWidgetElement.style.left) / CELL_SIZE);
            let gridY = Math.round(parseFloat(draggedWidgetElement.style.top) / CELL_SIZE);

            // Get widget dimensions from its dataset
            const widgetGridWidth = parseInt(draggedWidgetElement.dataset.gridWidth) || 1;
            const widgetGridHeight = parseInt(draggedWidgetElement.dataset.gridHeight) || 1;

            // Clamp to matrix boundaries to ensure the entire widget stays within
            gridX = Math.max(0, Math.min(gridX, MATRIX_WIDTH - widgetGridWidth));
            gridY = Math.max(0, Math.min(gridY, MATRIX_HEIGHT - widgetGridHeight));
            
            // Snap visual element to grid (top-left corner)
            draggedWidgetElement.style.left = (gridX * CELL_SIZE) + 'px';
            draggedWidgetElement.style.top = (gridY * CELL_SIZE) + 'px';

            // Store the current widget element before setting the global to null
            const releasedWidgetElement = draggedWidgetElement;
            
            // Remove the event listener and reset the global variable BEFORE the async operation
            document.removeEventListener('mousemove', onMouseMove);
            draggedWidgetElement = null;

            // Update the layout object
            if (currentScreenLayouts && currentScreenLayouts[jsCurrentDisplayMode] && currentScreenLayouts[jsCurrentDisplayMode].widgets) {
                const widgetToUpdate = currentScreenLayouts[jsCurrentDisplayMode].widgets.find(w => w.id === widgetId);
                if (widgetToUpdate) {
                    widgetToUpdate.x = gridX;
                    widgetToUpdate.y = gridY;
                    console.log(`Widget ${widgetId} new position: X=${gridX}, Y=${gridY}`);
                    saveUpdatedLayouts(); // Save and refresh
                }
            }
            
            // mouseup listener is already removed due to { once: true }
            // draggedWidgetElement = null; - MOVED EARLIER to prevent race condition
        }

        async function saveUpdatedLayouts() {
            try {
                const response = await fetch('/api/save_screen_layouts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currentScreenLayouts),
                });
                if (!response.ok) {
                    const errorResult = await response.json();
                    throw new Error(errorResult.message || 'Failed to save layouts on backend');
                }
                const result = await response.json();
                if (result.success) {
                    console.log('Layouts saved successfully via drag-drop.');
                    // Fetch matrix data again to show the change reflected from backend
                    await fetchAndUpdateMatrix(); 
                } else {
                    throw new Error(result.message || 'Backend reported save failure.');
                }
            } catch (error) {
                console.error('Error saving layouts:', error);
                // Optionally, display a user-facing error message
                // alert(`Error saving widget position: ${error.message}`);
                // Re-fetch layouts to revert to last known good state from server?
                // await fetchScreenLayoutsAndRenderAll(); // This might be too disruptive
            }
        }
        
        function updateMenuButtons(activeMode) {
            jsCurrentDisplayMode = activeMode; // Ensure our JS variable for current screen is up to date
            
            // Clear active state from all main menu buttons initially
            // The concept of a single 'active' button in the main nav (Prev/Next/Configure) is less direct now.
            // 'Configure Widgets' is a navigation, not a display mode itself.
            // Prev/Next change the mode, which is reflected in liveScreenSelector.
            [menuButtons.previous, menuButtons.next, menuButtons.configure].forEach(button => {
                if (button) button.classList.remove('active');
            });

            // Optional: If you want to highlight 'Configure Widgets' if on /config page (though user is on index.html here)
            // This function is primarily for index.html state based on jsCurrentDisplayMode.

            // Update the live screen selector as well
            if (liveScreenSelector) {
                liveScreenSelector.value = activeMode;
            }
        }

        async function setDisplayMode(mode, isAutoRotation = false) {
            try {
                // If rotation is active and this is a manual change, stop rotation.
                if (enableScreenRotationCheckbox.checked && !isAutoRotation) {
                    // Inform server to stop auto rotation
                    try {
                        await fetch('/api/set_auto_rotation_status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ enabled: false })
                        });
                    } catch (error) {
                        console.error('Error disabling auto rotation:', error);
                    }
                    enableScreenRotationCheckbox.checked = false;
                    manageRotationControls(false);
                }

                const response = await fetch(`/api/set_display_mode/${mode}`, { method: 'POST' });
                if (!response.ok) {
                    console.error(`Failed to set display mode to ${mode}:`, response.status);
                    return;
                }
                console.log(`Display mode set to ${mode}`);
                updateMenuButtons(mode); // This will update jsCurrentDisplayMode and liveScreenSelector
                await fetchAndUpdateMatrix(); 
                await fetchScreenLayouts(); 
                renderDraggableWidgets(); 
            } catch (error) {
                console.error(`Error setting display mode to ${mode}:`, error);
            }
        }

        if (menuButtons.previous) {
            menuButtons.previous.addEventListener('click', async () => {
                if (enableScreenRotationCheckbox.checked) { // Stop rotation on manual navigation
                    // Inform server to stop auto rotation
                    try {
                        await fetch('/api/set_auto_rotation_status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ enabled: false })
                        });
                    } catch (error) {
                        console.error('Error disabling auto rotation:', error);
                    }
                    enableScreenRotationCheckbox.checked = false;
                    manageRotationControls(false);
                }
                const screenIds = Object.keys(currentScreenLayouts).sort();
                if (screenIds.length === 0) return;
                let currentIndex = screenIds.indexOf(jsCurrentDisplayMode);
                if (currentIndex === -1) currentIndex = 0; // Fallback if current mode not found
                const newIndex = (currentIndex - 1 + screenIds.length) % screenIds.length;
                setDisplayMode(screenIds[newIndex]);
            });
        }

        if (menuButtons.next) {
            menuButtons.next.addEventListener('click', async () => {
                if (enableScreenRotationCheckbox.checked) { // Stop rotation on manual navigation
                    // Inform server to stop auto rotation
                    try {
                        await fetch('/api/set_auto_rotation_status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ enabled: false })
                        });
                    } catch (error) {
                        console.error('Error disabling auto rotation:', error);
                    }
                    enableScreenRotationCheckbox.checked = false;
                    manageRotationControls(false);
                }
                const screenIds = Object.keys(currentScreenLayouts).sort();
                if (screenIds.length === 0) return;
                let currentIndex = screenIds.indexOf(jsCurrentDisplayMode);
                if (currentIndex === -1) currentIndex = 0; // Fallback
                const newIndex = (currentIndex + 1) % screenIds.length;
                setDisplayMode(screenIds[newIndex]);
            });
        }

        if (menuButtons.configure) {
            menuButtons.configure.addEventListener('click', () => {
                window.location.href = '/config';
            });
        }

        // Function to populate the new live screen selector
        function populateLiveScreenSelector() {
            if (!liveScreenSelector) return;
            const previousSelectedValue = liveScreenSelector.value;
            liveScreenSelector.innerHTML = ''; // Clear existing options

            const screenIds = Object.keys(currentScreenLayouts);
            if (screenIds.length === 0) {
                const option = document.createElement('option');
                option.textContent = "No screens available";
                option.disabled = true;
                liveScreenSelector.appendChild(option);
                return;
            }

            screenIds.sort().forEach(screenId => {
                const option = document.createElement('option');
                option.value = screenId;
                option.textContent = currentScreenLayouts[screenId].name || screenId;
                liveScreenSelector.appendChild(option);
            });

            // Try to reselect previous value or current display mode, or first available
            if (currentScreenLayouts[jsCurrentDisplayMode]) {
                liveScreenSelector.value = jsCurrentDisplayMode;
            } else if (currentScreenLayouts[previousSelectedValue]) {
                liveScreenSelector.value = previousSelectedValue;
            } else if (screenIds.length > 0) {
                liveScreenSelector.value = screenIds[0];
                // If we had to pick the first, and it's different from jsCurrentDisplayMode, update jsCurrentDisplayMode.
                // However, setDisplayMode should be the single source of truth for changing modes.
                // This will be handled because updateMenuButtons called by setDisplayMode will update liveScreenSelector.value.
            }
        }

        // Event listener for the new live screen selector
        if (liveScreenSelector) {
            liveScreenSelector.addEventListener('change', (event) => {
                const selectedMode = event.target.value;
                if (selectedMode && currentScreenLayouts[selectedMode]) {
                    setDisplayMode(selectedMode); // Manual change, rotation will be stopped if active
                }
            });
        }

        function manageRotationControls(isRotating) {
            if (liveScreenSelector) liveScreenSelector.disabled = isRotating;
            if (menuButtons.previous) menuButtons.previous.disabled = isRotating;
            if (menuButtons.next) menuButtons.next.disabled = isRotating;
        }

        function scheduleNextScreen(screenIds, currentIndex) {
            if (!enableScreenRotationCheckbox.checked || screenIds.length < 2) {
                stopScreenRotation(); // Stop if checkbox unchecked or not enough screens
                return;
            }

            const nextIndex = (currentIndex + 1) % screenIds.length;
            const nextScreenId = screenIds[nextIndex];
            const currentScreenConfig = currentScreenLayouts[jsCurrentDisplayMode]; // Get current screen for its display time
            
            if (!currentScreenConfig || !currentScreenConfig.display_time_seconds) {
                console.warn(`Screen ${jsCurrentDisplayMode} has no valid display_time_seconds. Stopping rotation.`);
                stopScreenRotation();
                enableScreenRotationCheckbox.checked = false;
                return;
            }
            
            const displayTimeMs = currentScreenConfig.display_time_seconds * 1000;

            rotationTimeoutId = setTimeout(async () => {
                if (!enableScreenRotationCheckbox.checked) { // Re-check before switching
                    stopScreenRotation();
                    return;
                }
                currentRotationScreenIndex = nextIndex; // Update before setting mode for next schedule
                await setDisplayMode(nextScreenId, true); // true indicates it's an auto-rotation change
                scheduleNextScreen(screenIds, nextIndex); // Schedule the *next* one after this one is set
            }, displayTimeMs);
        }

        function startScreenRotation() {
            if (rotationTimeoutId) {
                clearTimeout(rotationTimeoutId);
                rotationTimeoutId = null;
            }
            manageRotationControls(true);

            const screenIds = Object.keys(currentScreenLayouts).sort();
            if (screenIds.length < 2) {
                displayMessage('Need at least 2 screens to start rotation.', 'error');
                enableScreenRotationCheckbox.checked = false;
                manageRotationControls(false);
                return;
            }
            
            // Determine starting point: current screen or first in list
            let startIndex = screenIds.indexOf(jsCurrentDisplayMode);
            if (startIndex === -1) {
                startIndex = 0; // Default to first screen if current isn't in the list (e.g., after a delete)
                jsCurrentDisplayMode = screenIds[0];
            }
            currentRotationScreenIndex = startIndex;
            
            // Immediately display the first screen in sequence if not already displayed, or just schedule next if it is.
            // For simplicity, let's ensure the current is set and then schedule its successor.
            setDisplayMode(jsCurrentDisplayMode, true).then(() => {
                 // Pass currentRotationScreenIndex which is already set to the index of jsCurrentDisplayMode
                scheduleNextScreen(screenIds, currentRotationScreenIndex); 
            });
        }

        function stopScreenRotation() {
            if (rotationTimeoutId) {
                clearTimeout(rotationTimeoutId);
                rotationTimeoutId = null;
            }
            manageRotationControls(false);
            console.log("Screen rotation stopped.");
        }

        if (enableScreenRotationCheckbox) {
            enableScreenRotationCheckbox.addEventListener('change', async () => {
                try {
                    const response = await fetch('/api/set_auto_rotation_status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ enabled: enableScreenRotationCheckbox.checked })
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to set auto rotation status:', response.status);
                        // Revert checkbox state if server update failed
                        enableScreenRotationCheckbox.checked = !enableScreenRotationCheckbox.checked;
                        return;
                    }
                    
                    const data = await response.json();
                    console.log(`Auto rotation ${data.enabled ? 'enabled' : 'disabled'}`);
                    
                    if (data.enabled) {
                        // Server-side rotation is now enabled
                        manageRotationControls(true);
                    } else {
                        // Server-side rotation is now disabled
                        manageRotationControls(false);
                    }
                } catch (error) {
                    console.error('Error setting auto rotation status:', error);
                    // Revert checkbox state if request failed
                    enableScreenRotationCheckbox.checked = !enableScreenRotationCheckbox.checked;
                }
            });
            
            // Initialize checkbox state from server on page load
            fetchAutoRotationStatus();
        }
        
        // Add function to fetch current auto rotation status
        async function fetchAutoRotationStatus() {
            try {
                const response = await fetch('/api/get_auto_rotation_status');
                if (response.ok) {
                    const data = await response.json();
                    enableScreenRotationCheckbox.checked = data.enabled;
                    if (data.enabled) {
                        manageRotationControls(true);
                    } else {
                        manageRotationControls(false);
                    }
                }
            } catch (error) {
                console.error('Error fetching auto rotation status:', error);
            }
        }

        // Initial setup
        async function initializeSimulator() {
            await fetchScreenLayouts(); // Fetches layouts, and calls populateLiveScreenSelector if needed
            
            // Set initial state of bounding boxes based on checkbox
            // if (toggleBoundingBoxesCheckbox) { // REMOVED
            //     if (toggleBoundingBoxesCheckbox.checked) {
            //         widgetOverlayContainer.classList.remove('bounding-boxes-hidden');
            //     } else {
            //         widgetOverlayContainer.classList.add('bounding-boxes-hidden');
            //     }
            // }
            updateEditModeButtonState(); // Set initial button text/style and overlay visibility

            await fetchAndUpdateMatrix(); 
            await fetchAutoRotationStatus(); // Get initial auto rotation status
            updateMenuButtons(jsCurrentDisplayMode); 
            setInterval(async () => {
                await fetchAndUpdateMatrix(); 
            }, 50);
        }

        // --- Matrix Log Toggle --- 
        async function updateMatrixLogToggleText(isLoggingEnabled) {
            toggleMatrixLogsBtn.textContent = isLoggingEnabled ? "Matrix Logs: ON" : "Matrix Logs: OFF";
            toggleMatrixLogsBtn.classList.remove(isLoggingEnabled ? 'logs-off' : 'logs-on');
            toggleMatrixLogsBtn.classList.add(isLoggingEnabled ? 'logs-on' : 'logs-off');
        }

        async function fetchMatrixLoggingStatus() {
            try {
                const response = await fetch('/api/get_matrix_logging_status');
                if (response.ok) {
                    const data = await response.json();
                    updateMatrixLogToggleText(data.enabled);
                    toggleMatrixLogsBtn.classList.add('control-button'); // Add base class for styling
                }
            } catch (error) {
                console.error("Error fetching matrix logging status:", error);
                toggleMatrixLogsBtn.textContent = "Matrix Logs: Error";
                toggleMatrixLogsBtn.classList.remove('logs-on');
                toggleMatrixLogsBtn.classList.add('logs-off');
            }
        }

        toggleMatrixLogsBtn.addEventListener('click', async () => {
            let currentStatus = toggleMatrixLogsBtn.textContent.includes("ON");
            let newStatus = !currentStatus;
            try {
                const response = await fetch('/api/set_matrix_logging_status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled: newStatus })
                });
                if (response.ok) {
                    const data = await response.json();
                    updateMatrixLogToggleText(data.enabled);
                } else {
                    console.error("Error setting matrix logging status");
                    const oldText = toggleMatrixLogsBtn.textContent;
                    toggleMatrixLogsBtn.textContent = "Matrix Logs: Error";
                    setTimeout(() => { toggleMatrixLogsBtn.textContent = oldText; }, 2000);
                }
            } catch (error) {
                console.error("Error setting matrix logging status:", error);
                const oldText = toggleMatrixLogsBtn.textContent;
                toggleMatrixLogsBtn.textContent = "Matrix Logs: Error";
                setTimeout(() => { toggleMatrixLogsBtn.textContent = oldText; }, 2000);
            }
        });

        // --- Initialization and Main Loop ---
        async function fetchMatrixDataAndUpdate() {
            await fetchAndUpdateMatrix();
        }

        async function fetchScreenLayoutsAndUpdateSelector() {
            await fetchScreenLayouts();
            populateLiveScreenSelector();
        }

        async function fetchMatrixLoggingStatusAndUpdate() {
            await fetchMatrixLoggingStatus();
        }

        // Fetch initial data and start periodic updates
        fetchMatrixDataAndUpdate(); 
        fetchScreenLayoutsAndUpdateSelector(); // Fetch all layouts for the selector
        fetchMatrixLoggingStatusAndUpdate(); // Get initial state of matrix log toggle
        
        // setInterval(fetchMatrixDataAndUpdate, 1000); // Already have one in initializeSimulator
        setInterval(fetchScreenLayoutsAndUpdateSelector, 15000); // Periodically update layouts for selector (e.g., if changed elsewhere)

        // --- Edit Mode Toggle Button Logic ---
        function updateEditModeButtonState() {
            if (isEditMode) {
                toggleEditModeBtn.textContent = "EDIT Mode";
                toggleEditModeBtn.classList.remove('live-mode');
                toggleEditModeBtn.classList.add('edit-mode');
                widgetOverlayContainer.classList.remove('bounding-boxes-hidden');
                renderDraggableWidgets(); // Ensure widgets are shown if switching to edit mode
            } else {
                toggleEditModeBtn.textContent = "LIVE Mode";
                toggleEditModeBtn.classList.remove('edit-mode');
                toggleEditModeBtn.classList.add('live-mode');
                widgetOverlayContainer.classList.add('bounding-boxes-hidden');
            }
            toggleEditModeBtn.classList.add('control-button'); // Add base class for styling
        }

        toggleEditModeBtn.addEventListener('click', () => {
            isEditMode = !isEditMode;
            updateEditModeButtonState();
            // If switching to edit mode, and widgets aren't rendered yet, render them.
            // If switching to live mode, the classList.add will hide them via CSS.
            if (isEditMode) {
                renderDraggableWidgets();
            }
        });

        initializeSimulator();
    </script>
</body>
</html> 